<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="/static/Chart.js-2.8.0/dist/Chart.css">
    <link rel="stylesheet" type="text/css" href="/static/admin/css/base.css">
    <link rel="stylesheet" type="text/css" href="/static/admin/css/changelists.css">
    <link rel="stylesheet" type="text/css" href="/static/review.css">
    <script type="text/javascript" src="/admin/jsi18n/"></script>
    <script type="text/javascript" src="/static/jquery-3.4.1.min.js"></script>
    <script type="text/javascript" src="/static/admin/js/vendor/jquery/jquery.js"></script>
    <script type="text/javascript" src="/static/admin/js/jquery.init.js"></script>
    <script type="text/javascript" src="/static/admin/js/core.js"></script>
    <script type="text/javascript" src="/static/admin/js/admin/RelatedObjectLookups.js"></script>
    <script type="text/javascript" src="/static/admin/js/actions.js"></script>
    <script type="text/javascript" src="/static/admin/js/urlify.js"></script>
    <script type="text/javascript" src="/static/admin/js/prepopulate.js"></script>
    <script type="text/javascript" src="/static/admin/js/vendor/xregexp/xregexp.js"></script>
    <script type="text/javascript" src="/static/Chart.js-2.8.0/dist/Chart.bundle.js"></script>
    <script type="text/javascript" src="/static/Chart.js-2.8.0/dist/chartjs-plugin-annotation.js"></script>

    <title>Review, {{ bed }}, {{ date }}</title>
</head>
<body>

<h1 align="center"> {{ bed }}, {{ date }} </h1>

<div class="results">
    <table id="annotation_list">
        <thead>
        <tr>
            <th scope="col"  class="column-bed_name">
                <div class="text"><span>number</span></div>
                <div class="clear"></div>
            </th>
            <th scope="col"  class="column-bed_name">
                <div class="text"><span>dt</span></div>
                <div class="clear"></div>
            </th>
            <th scope="col"  class="column-bed_name">
                <div class="text"><span>method</span></div>
                <div class="clear"></div>
            </th>
            <th scope="col"  class="column-bed_name">
                <div class="text"><span>description</span></div>
                <div class="clear"></div>
            </th>
        </tr>
        </thead>
    </table>
</div>

{% for ch in wave %}
    <label><input type="checkbox" id="cbx_{{ forloop.counter0 }}"{% if ch.is_main %} checked{% endif %} onclick="update_wave_list()"> {{ ch.device }}, {{ ch.channel }} <br></label>
{% endfor %}

<div class="slidecontainer">
  <input type="range" min="0" max="100" value="50" class="slider" id="waveTimeSlider">
</div>

{% for ch in wave %}
    <div id="div_{{ forloop.counter0 }}">
    <canvas id="cvs_{{ forloop.counter0 }}"> width="400" height="50"></canvas>
    </div>
{% endfor %}

{% for n in num %}
    <div id="num_div_{{ forloop.counter0 }}">
        <h4 align="center"> {{ n.device_displayed_name }}, <a href="/download_csv_device?{{ n.csv_download_params | safe }}">Download CSV</a> </h4>
        <canvas id="num_cvs_{{ forloop.counter0 }}" class="chartjs" width="400" height="200"></canvas>
    </div>

{% endfor %}

<ul id="contextMenu" style="display:none;">
    <li class="menu-item" onclick="menu(1)">Add Event</li>
    <li class="menu-item" onclick="menu(2)">Menu 2</li>
</ul>

<script>

    let begin_date = new Date('{{ begin_date }}');
    let end_date = new Date('{{ end_date }}');

    let wave_begin_date = new Date(begin_date);
    wave_begin_date.setSeconds(Math.ceil(wave_begin_date.getSeconds()/10)*10);

    let wave_dt_list = [];
    // loop for every day
    for (let dt = wave_begin_date; dt <= end_date; dt.setSeconds(dt.getSeconds()+10)) {
        wave_dt_list.push(new Date(dt));
    }
    let dt_pointer = Math.floor(wave_dt_list.length/2);

    let slider = document.getElementById("waveTimeSlider");
    slider.max = wave_dt_list.length;
    slider.value = dt_pointer;
    slider.oninput = function() {
        dt_pointer = this.value;
        for (let i=0; i<number_charts.length; i++) {
            number_charts[i].chart.options.annotation.annotations[0].value = wave_dt_list[dt_pointer];
            number_charts[i].chart.update();
        }
        update_wave_data();
    };

    function update_wave_list() {
        for (let i=0; i<wave_charts.length; i++) {
            if ( document.getElementById(wave_charts[i].cbx_id).checked ) {
                document.getElementById(wave_charts[i].div_id).style.display="block";
                wave_charts[i].chart.update();
            } else {
                document.getElementById(wave_charts[i].div_id).style.display="none";
            }
        }
    }

    function update_wave() {
        for (let i=0; i<wave_charts.length; i++) {
            if ( document.getElementById(wave_charts[i].cbx_id).checked ) {
                let xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function () {
                    if (this.readyState === 4 && this.status === 200) {
                        let d = JSON.parse(xhttp.responseText);
                        let init_dt = new Date(d.timestamp[0]);
                        wave_charts[i].chart.data.labels = [];
                        wave_charts[i].chart.data.datasets = [];
                        let tmp_dataset = {label: wave_charts[i].channel, data: []};
                        for (let j = 0; j < d['data'][0].length; j++) {
                            let c_dt = new Date(init_dt);
                            c_dt.setMilliseconds(init_dt.getMilliseconds() + j * 1000 / d['sampling_rate']);
                            wave_charts[i].chart.data.labels.push(c_dt);
                            tmp_dataset.data.push(d['data'][0][j]);
                        }
                        wave_charts[i].chart.data.datasets.push(tmp_dataset);
                    }
                    wave_charts[i].chart.update();
                };
                xhttp.open("GET", "get_wavedata?file={{ vital_file }}&dt=" + wave_dt_list[dt_pointer].toISOString() +
                    "&device_code=" + wave_charts[i].device_code + "&channel=" + wave_charts[i].channel, true);
                xhttp.send();
            }
        }
    }

    let number_annotation = {
        drawTime: 'afterDatasetsDraw',
        annotations: [{
            type: 'line',
            mode: 'vertical',
            scaleID: 'x-axis-0',
            value: wave_dt_list[dt_pointer],
            borderColor: 'red',
            borderWidth: 1,
            label: {
                enabled: true,
                position: "top",
                content: false
            }
        }]
    };

    let wave_annoation = {
        drawTime: 'afterDatasetsDraw',
        annotations: []
    };

    let event_info = {
        drawTime: 'afterDatasetsDraw',
        annotations: []
    };

    let num_data = {{ num_json | safe }};
    let number_charts = [];

    for (let i=0; i<num_data.length; i++) {
        let tmp_num = {};
        tmp_num.device = num_data[i].device;
        tmp_num.div_id = "num_div_" + i;
        tmp_num.cvs_id = "num_cvs_" + i;
        tmp_num.chart = new Chart(document.getElementById(tmp_num.cvs_id), {
            type: "line",
            data: {
                labels: num_data[i].timestamp,
                datasets: num_data[i].dataset
            },
            options: {
                scales: {
                    xAxes: [{
                        type: "time",
                        distribution: "linear",
                        time: {
                            unit: "hour"
                        }
                    }]
                },
                layout: {
                    padding: {
                        left: 10,
                        right: 10,
                        top: 10,
                        bottom: 10
                    }
                },
                animation: {
                    duration: 0 // general animation time
                },
                annotation: number_annotation
            }
        });
        number_charts.push(tmp_num);
    }

    let waves = {{ wave_json | safe }};
    let wave_charts = [];

    for (let i=0; i<waves.length; i++) {
        let tmp_wave = {};
        tmp_wave.device = waves[i].device;
        tmp_wave.device_code = waves[i].device_code;
        tmp_wave.channel = waves[i].channel;
        tmp_wave.sampling_rate = waves[i].sampling_rate;
        tmp_wave.num_packets = waves[i].num_packets;
        tmp_wave.file_path = waves[i].file_path;
        tmp_wave.div_id = "div_" + i;
        tmp_wave.cvs_id = "cvs_" + i;
        tmp_wave.cbx_id = "cbx_" + i;
        tmp_wave.chart = new Chart(document.getElementById(tmp_wave.cvs_id), {
            type: "line",
            data: {
                labels: [],
                datasets: [],
                fill: false,
                pointRadius: 0,
                borderColor: 'black',
                lineTension: 0
            },
            options: {
                scales: {
                    xAxes: [{
                        type: "time",
                        time: {
                            unit: "second"
                        }
                    }]
                },
                layout: {
                    padding: {
                        left: 10,
                        right: 10,
                        top: 10,
                        bottom: 10
                    }
                },
                animation: {
                    duration: 0 // general animation time
                },
                annotation: wave_annoation
            }
        });
        wave_charts.push(tmp_wave);
    }

    let $menu = $('#contextMenu'), dt_context_menu;
    for (let i=0; i<number_charts.length; i++) {
        let canvas = document.getElementById(number_charts[i].cvs_id);
        canvas.addEventListener('contextmenu', handleContextMenu, false);
        canvas.addEventListener('mousedown', handleMouseDown, false);
    }
    for (let i=0; i<wave_charts.length; i++) {
        let canvas = document.getElementById(wave_charts[i].cvs_id);
        canvas.addEventListener('contextmenu', handleContextMenu, false);
        canvas.addEventListener('mousedown', handleMouseDown, false);
    }

    function UpdateAnnotationData(annotation_data){
        number_annotation.annotations.length = 1;
        let annotation_table = document.getElementById('annotation_list');
        let row_count = annotation_table.rows.length;
        while (--row_count) {
            annotation_table.deleteRow(row_count);
        }
        for (let i=0; i<annotation_data.length; i++) {
            let row = annotation_table.insertRow(i+1);
            row.insertCell(0).innerHTML = i+1;
            row.insertCell(1).innerHTML = new Date(annotation_data[i].dt).toLocaleString();
            row.insertCell(2).innerHTML = annotation_data[i].method;
            row.insertCell(3).innerHTML = annotation_data[i].description;
            let single_event = {
                type: 'line',
                mode: 'vertical',
                scaleID: 'x-axis-0',
                value: annotation_data[i].dt,
                borderColor: 'green',
                borderWidth: 1,
                label: {
                    enabled: true,
                    position: "top",
                    content: i+1
                }
            };
            number_annotation.annotations.push(single_event);
        }

        for (let i=0; i<wave_charts.length; i++) {
            if (document.getElementById(wave_charts[i].cbx_id).checked) {
                wave_charts[i].chart.update();
            }
        }
        for (let i=0; i<number_charts.length; i++) {
            number_charts[i].chart.options.annotation = number_annotation;
            number_charts[i].chart.update();
        }
    }

    function AddAnnotation(dt, description){
        let xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function () {
            if (this.readyState === 4 && this.status === 200) {
                let result = JSON.parse(xhttp.responseText);
                UpdateAnnotationData(result.annotations);
            }
        };
        xhttp.open("GET", "add_annotation?file={{ vital_file }}&dt=" + dt.toISOString() + "&method=0&desc=" + description, true);
        xhttp.send();
    }

    function handleContextMenu(e){
        e.preventDefault();
        e.stopPropagation();
        let canvas = document.getElementById(number_charts[0].cvs_id);
        let BB = canvas.getBoundingClientRect(), offsetX = BB.left, offsetY = BB.top;
        let x = parseInt(e.clientX-offsetX);
        let y = parseInt(e.clientY-offsetY);
        dt_context_menu = new Date(number_charts[0].chart.data.labels[number_charts[0].chart.getElementAtEvent(e)[0]._index]);
        console.log(x, y, offsetX, offsetY);
        console.log(dt_context_menu);
        $menu.css({left:x,top:e.clientY});
        $menu.show();
        return false;
    }

    function handleMouseDown(e){
        $menu.hide();
    }

    menu = function(n){
        console.log("select menu "+n);
        AddAnnotation(dt_context_menu, 'Test');
        $menu.hide();
    };

    let xhttp = new XMLHttpRequest();
    xhttp.onreadystatechange = function () {
        if (this.readyState === 4 && this.status === 200) {
            let result = JSON.parse(xhttp.responseText);
            UpdateAnnotationData(result);
        }
    };
    xhttp.open("GET", "get_annotation?file={{ vital_file }}", true);
    xhttp.send();

    update_wave();
    update_wave_list();

</script>

</body>
</html>