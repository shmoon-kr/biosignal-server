<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="/static/Chart.js-2.8.0/dist/Chart.css">
    <link rel="stylesheet" type="text/css" href="/static/admin/css/base.css">
    <link rel="stylesheet" type="text/css" href="/static/admin/css/changelists.css">
    <link rel="stylesheet" type="text/css" href="/static/review.css">
    <script type="text/javascript" src="/admin/jsi18n/"></script>
    <script type="text/javascript" src="/static/jquery-3.4.1.min.js"></script>
    <script type="text/javascript" src="/static/admin/js/vendor/jquery/jquery.js"></script>
    <script type="text/javascript" src="/static/admin/js/jquery.init.js"></script>
    <script type="text/javascript" src="/static/admin/js/core.js"></script>
    <script type="text/javascript" src="/static/admin/js/admin/RelatedObjectLookups.js"></script>
    <script type="text/javascript" src="/static/admin/js/actions.js"></script>
    <script type="text/javascript" src="/static/admin/js/urlify.js"></script>
    <script type="text/javascript" src="/static/admin/js/prepopulate.js"></script>
    <script type="text/javascript" src="/static/admin/js/vendor/xregexp/xregexp.js"></script>
    <script type="text/javascript" src="/static/Chart.js-2.8.0/dist/Chart.bundle.js"></script>
    <script type="text/javascript" src="/static/Chart.js-2.8.0/dist/chartjs-plugin-annotation.js"></script>

    <title>Review, {{ bed }}, {{ date }}</title>
</head>
<body>

<h1 align="center"> {{ bed }}, {{ date }} </h1>

<div class="results">
    <table id="annotation_list">
        <thead>
        <tr>
            <th scope="col"  class="column-bed_name">
                <div class="text"><span>number</span></div>
                <div class="clear"></div>
            </th>
            <th scope="col"  class="column-bed_name">
                <div class="text"><span>dt</span></div>
                <div class="clear"></div>
            </th>
            <th scope="col"  class="column-bed_name">
                <div class="text"><span>method</span></div>
                <div class="clear"></div>
            </th>
            <th scope="col"  class="column-bed_name">
                <div class="text"><span>description</span></div>
                <div class="clear"></div>
            </th>
            <th scope="col"  class="column-bed_name">
                <div class="text"><span>action</span></div>
                <div class="clear"></div>
            </th>
        </tr>
        </thead>
    </table>
</div>

{% for key, val in meta_data.items %}
    {% if val.number %}
    <label><input type="checkbox" id="cbx_chart_{{ val.id }}"{% if val.is_main %} checked{% endif %} onclick="ToggleNumberChart('{{ val.id }}')"> {{ key }} <a href="/download_csv_device?{{ val.csv_download_params | safe }}">Download CSV</a> <br></label>
    {% endif %}
{% endfor %}

{% for device, info in meta_data.items %}
    {% for waveinfo in info.waves %}
        <label><input type="checkbox" id="cbx_chart_{{ waveinfo.id }}_{{ waveinfo.channel }}"{% if waveinfo.is_main %} checked{% endif %} onclick="ToggleWaveChart('{{ waveinfo.id }}_{{ waveinfo.channel }}')"> {{ device }}_{{ waveinfo.channel }} <br></label>
    {% endfor %}
{% endfor %}

<div class="slidecontainer">
  <input type="range" min="0" max="100" value="50" class="slider" id="waveTimeSlider">
</div>

{% for device, info in meta_data.items %}
    {% for waveinfo in info.waves %}
        <div id="div_chart_{{ waveinfo.id }}_{{ waveinfo.channel }}">
            <canvas id="cvs_chart_{{ waveinfo.id }}_{{ waveinfo.channel }}" class="chartjs" width="400" height="50"></canvas>
        </div>
    {% endfor %}
{% endfor %}

{% for key, val in meta_data.items %}
    {% if val.number and val.is_main %}
    <div id="div_chart_{{ val.id }}">
        <canvas id="cvs_chart_{{ val.id }}" class="chartjs" width="400" height="150"></canvas>
    </div>
    {% endif %}
{% endfor %}

<ul id="contextMenu" style="display:none;">
    <li class="menu-item" onclick="menu(1)">Add Event</li>
    <li class="menu-item" onclick="menu(2)">Menu 2</li>
</ul>

<script>

    let meta_data = {{ meta_data_json | safe }};
    let begin_date = new Date('{{ begin_date }}');
    let end_date = new Date('{{ end_date }}');
    let dt = new Date('{{ dt }}'), dt_pointer;

    let wave_begin_date = new Date(begin_date);
    wave_begin_date.setSeconds(Math.ceil(wave_begin_date.getSeconds()/10)*10);

    let wave_dt_list = [];
    // loop for every day
    for (let dt = wave_begin_date; dt <= end_date; dt.setSeconds(dt.getSeconds()+10)) {
        wave_dt_list.push(new Date(dt));
    }

    function binary_search(t_list, val, st, ed) {
        if (st + 1 === ed) {
            return st
        }
        let mid = Math.ceil((st+ed)/2);
        if (t_list[mid] > val) {
            return binary_search(t_list, val, st, mid)
        } else {
            return binary_search(t_list, val, mid, ed)
        }
    }

    if (dt == "Invalid Date") {
        dt_pointer = Math.floor(wave_dt_list.length/2);
    } else{
        dt_pointer = binary_search(wave_dt_list, dt, 0, wave_dt_list.length);
    }

    let slider = document.getElementById("waveTimeSlider");
    slider.max = wave_dt_list.length;
    slider.value = dt_pointer;
    slider.oninput = function() {
        dt_pointer = this.value;
        for (let [key, value] of Object.entries(number_charts)) {
            value.chart.options.annotation.annotations[0].value = wave_dt_list[dt_pointer];
            value.chart.update();
        }
        UpdateWaveData();
    };

    function ToggleNumberChart(id) {
        if ( document.getElementById('cbx_chart_'+id).checked) {
            document.getElementById('div_chart_'+id).style.display="block";
            if (number_charts[id].data_load) {
                number_charts[id].chart.update();
            } else {
                let xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function () {
                    if (this.readyState === 4 && this.status === 200) {
                        let d = JSON.parse(xhttp.responseText);
                        for (let i=0; i<d.dataset.length; i++) {
                            for (let j=0; j<d.dataset[i].data.length; j++) {
                                if (!d.dataset[i].data[j]) {
                                    d.dataset[i].data[j] = NaN;
                                }
                            }
                        }
                        number_charts[id].chart.data.labels = d.timestamp;
                        number_charts[id].chart.data.datasets = d.dataset;
                        number_charts[id].chart.update();
                    }
                };
                xhttp.open("GET", "get_numberdata?file={{ vital_file }}&device_id="+id, true);
                xhttp.send();
            }
        } else {
            document.getElementById('div_chart_'+id).style.display="none";
        }
    }

    function ToggleWaveChart(id) {
        if ( document.getElementById('cbx_chart_'+id).checked) {
            document.getElementById('div_chart_'+id).style.display="block";
            let value = wave_charts[id];
            let xhttp = new XMLHttpRequest();
            xhttp.onreadystatechange = function () {
                if (this.readyState === 4 && this.status === 200) {
                    let d = JSON.parse(xhttp.responseText);
                    let init_dt = new Date(d.timestamp[0]);
                    value.chart.data.labels = [];
                    value.chart.data.datasets = [];
                    let tmp_dataset = {label: value.channel, data: []};
                    for (let j = 0; j < d['data'][0].length; j++) {
                        let c_dt = new Date(init_dt);
                        c_dt.setMilliseconds(init_dt.getMilliseconds() + j * 1000 / d['sampling_rate']);
                        value.chart.data.labels.push(c_dt);
                        tmp_dataset.data.push(d['data'][0][j]);
                    }
                    tmp_dataset['fill'] = false;
                    tmp_dataset['lineTension'] = 0;
                    tmp_dataset['pointRadius'] = 0;
                    tmp_dataset['borderColor'] = 'black';
                    value.chart.data.datasets.push(tmp_dataset);
                    value.chart.options.annotation = wave_annotation;
                    value.chart.update();
                }
            };
            xhttp.open("GET", "get_wavedata?file={{ vital_file }}&dt=" + wave_dt_list[dt_pointer].toISOString() +
                "&device_code=" + value.device_code + "&channel=" + value.channel, true);
            xhttp.send();
        } else {
            document.getElementById('div_chart_'+id).style.display="none";
        }
    }

    function UpdateWaveData() {
        UpdateWaveAnnotationData();
        UpdateWaveAnnotation();
        for (let [key, value] of Object.entries(wave_charts)) {
            ToggleWaveChart(key);
        }
    }

    let number_annotation = {
        drawTime: 'afterDatasetsDraw',
        annotations: [{
            type: 'line',
            mode: 'vertical',
            scaleID: 'x-axis-0',
            value: wave_dt_list[dt_pointer],
            borderColor: 'red',
            borderWidth: 1,
            label: {
                enabled: true,
                position: "top",
                content: false
            }
        }]
    };

    let wave_annotation = {
        drawTime: 'afterDatasetsDraw',
        annotations: []
    };

    let number_charts = {};

    for (let [key, value] of Object.entries(meta_data)) {
        if (value.number && value.is_main) {
            let tmp_number_chart = {};
            tmp_number_chart.device = key;
            tmp_number_chart.data_load = false;
            tmp_number_chart.chart = new Chart(document.getElementById("cvs_chart_"+value.id), {
                type: "line",
                data: {
                    labels: [],
                    datasets: {}
                },
                options: {
                    scales: {
                        xAxes: [{
                            type: "time",
                            distribution: "linear",
                            time: {
                                unit: "hour"
                            }
                        }]
                    },
                    layout: {
                        padding: {
                            left: 10,
                            right: 10,
                            top: 10,
                            bottom: 10
                        }
                    },
                    animation: {
                        duration: 0 // general animation time
                    },
                    title: {
                        display: true,
                        text: key
                    },
                    annotation: number_annotation
                }
            });
            number_charts[value.id] = tmp_number_chart;
            ToggleNumberChart(value.id);
        }
    }

    let wave_charts = {};
    for (let [key, value] of Object.entries(meta_data)) {
        for (let i=0; i<value.waves.length; i++) {
            let tmp_wave = {};
            tmp_wave.device = key;
            tmp_wave.device_id = value.waves[i].id;
            tmp_wave.device_code = value.waves[i].device_code;
            tmp_wave.channel = value.waves[i].channel;
            tmp_wave.sampling_rate = value.waves[i].sampling_rate;
            tmp_wave.num_packets = value.waves[i].num_packets;
            tmp_wave.file_path = value.waves[i].file_path;
            tmp_wave.chart = new Chart(document.getElementById('cvs_chart_'+tmp_wave.device_id+'_'+tmp_wave.channel), {
                type: "line",
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    scales: {
                        xAxes: [{
                            type: "time",
                            time: {
                                unit: "second"
                            }
                        }]
                    },
                    layout: {
                        padding: {
                            left: 10,
                            right: 10,
                            top: 10,
                            bottom: 10
                        }
                    },
                    animation: {
                        duration: 0 // general animation time
                    },
                    title: {
                        display: true,
                        text: tmp_wave.device+'_'+tmp_wave.channel
                    },
                    legend: {
                        display: false
                    },
                    annotation: wave_annotation
                }
            });
            wave_charts[tmp_wave.device_id+'_'+tmp_wave.channel]=tmp_wave;
        }
    }

    let $menu = $('#contextMenu'), dt_context_menu;
    for (let [key, value] of Object.entries(number_charts)) {
        let canvas = document.getElementById('cvs_chart_'+key);
        canvas.addEventListener('contextmenu', handleContextMenu, false);
        canvas.addEventListener('mousedown', handleMouseDown, false);
    }
    for (let [key, value] of Object.entries(wave_charts)) {
        let canvas = document.getElementById('cvs_chart_'+key);
        canvas.addEventListener('contextmenu', handleContextMenu, false);
        canvas.addEventListener('mousedown', handleMouseDown, false);
    }

    function UpdateAnnotationData(url){
        let xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function () {
            if (this.readyState === 4 && this.status === 200) {
                let annotation_data = JSON.parse(xhttp.responseText);
                number_annotation.annotations.length = 1;
                let annotation_table = document.getElementById('annotation_list');
                let row_count = annotation_table.rows.length;
                while (--row_count) {
                    annotation_table.deleteRow(row_count);
                }
                for (let i=0; i<annotation_data.length; i++) {
                    let row = annotation_table.insertRow(i+1);
                    row.insertCell(0).innerHTML = i+1;
                    row.insertCell(1).innerHTML = new Date(annotation_data[i].dt).toLocaleString();
                    row.insertCell(2).innerHTML = annotation_data[i].method;
                    row.insertCell(3).innerHTML = annotation_data[i].description;
                    row.insertCell(4).innerHTML = '<button type="button" onclick="DeleteAnnotation(' + annotation_data[i].id + ')">Delete</button>';
                    let single_event = {
                        type: 'line',
                        mode: 'vertical',
                        scaleID: 'x-axis-0',
                        value: new Date(annotation_data[i].dt),
                        borderColor: 'green',
                        borderWidth: 1,
                        label: {
                            enabled: true,
                            position: "top",
                            content: i+1
                        }
                    };
                    number_annotation.annotations.push(single_event);
                }
                for (let [key, value] of Object.entries(number_charts)) {
                    value.chart.options.annotation = number_annotation;
                    value.chart.update();
                }
                UpdateWaveAnnotationData();
                UpdateWaveAnnotation();
            }
        };
        xhttp.open("GET", url, true);
        xhttp.send();
    }

    function UpdateWaveAnnotationData() {
        wave_annotation.annotations = [];
        for (let i = 1; i < number_annotation.annotations.length; i++) {
            if (Math.abs(number_annotation.annotations[i].value - wave_dt_list[dt_pointer]) < 10000) {
                wave_annotation.annotations.push(number_annotation.annotations[i]);
            }
        }
    }

    function UpdateWaveAnnotation() {
        for (let [key, value] of Object.entries(wave_charts)) {
            if (document.getElementById('cbx_chart_'+key).checked) {
                value.chart.options.annotation = wave_annotation;
            }
        }
    }

    function AddAnnotation(dt, description){
        UpdateAnnotationData("add_annotation?file={{ vital_file }}&dt=" + dt.toISOString() + "&method=0&desc=" + description);
    }

    function DeleteAnnotation(i) {
        UpdateAnnotationData("delete_annotation?file={{ vital_file }}&id=" + i);
    }

    function handleContextMenu(e){
        e.preventDefault();
        e.stopPropagation();
        let canvas = e.target;
        let id = canvas.id.replace('cvs_chart_','');
        let chart = id.includes('_')?wave_charts[id].chart:number_charts[id].chart;
        if (chart.getElementAtEvent(e).length) {
            dt_context_menu = new Date(chart.data.labels[chart.getElementAtEvent(e)[0]._index]);
            $menu.css({left:e.pageX,top:e.pageY});
            $menu.show();
        }
        return false;
    }

    function handleMouseDown(e){
        $menu.hide();
    }

    menu = function(n){
        AddAnnotation(dt_context_menu, 'Test');
        $menu.hide();
    };

    UpdateAnnotationData("get_annotation?file={{ vital_file }}");
    UpdateWaveData();

</script>

</body>
</html>